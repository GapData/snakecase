% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/to_any_case.R
\name{to_any_case}
\alias{to_any_case}
\title{General case conversion}
\usage{
to_any_case(string, case = c("snake", "small_camel", "big_camel",
  "screaming_snake", "parsed", "mixed", "lower_upper", "upper_lower",
  "all_caps", "lower_camel", "upper_camel", "none"), preprocess = NULL,
  protect = NULL, replace_special_characters = NULL, postprocess = NULL,
  prefix = "", postfix = "", unique_sep = NULL, empty_fill = NULL,
  parsingoption = 1)
}
\arguments{
\item{string}{A string (for example names of a data frame).}

\item{case}{The desired target case, provided as one of the following:
\itemize{
 \item{snake_case: \code{"snake"}}
 \item{lowerCamel: \code{"lower_camel"} or \code{"small_camel"}}
 \item{UpperCamel: \code{"upper_camel"} or \code{"big_camel"}}
 \item{ALL_CAPS: \code{"screaming_snake"} or \code{"all_caps"}}
 \item{lowerUPPER: \code{"lower_upper"}}
 \item{UPPERlower: \code{"upper_lower"}}
 }

 There are three "special" cases available:
\itemize{
 \item{\code{"parsed"}: This case is underlying all other cases. 
 Every substring a string consists
 of becomes surrounded by an underscore (depending on the \code{parsingoption}).
  Underscores at the start and end are trimmed. No lower or 
 upper case pattern from the input string are changed.}
 \item{\code{"mixed"}: Almost the same as \code{case = "parsed"}. Every letter which is not at the start
 or behind an underscore is turned into lowercase.}
 \item{\code{"none"}: Neither parsing nor caseconversion occur. This case might be helpful, when
 one wants to call the function for the quick usage of the other parameters.
 Works with \code{replace_special_characters}, \code{prefix}, \code{postfix},
  \code{empty_fill} and \code{unique_sep}.}
 }}

\item{preprocess}{A string (if not \code{NULL}) that will be wrapped internally
into \code{stringr::regex()}. All matches will be replaced by underscores.}

\item{protect}{A string (if not \code{NULL}) which is a valid \code{stringr::regex()}. Matches within the input
won't have any "_" beside within the output.
Note that \code{preprocess} has a higher precedence than protect, 
which means that it doesn't make sense to protect sth. which is already replaced
via \code{preprocess}.}

\item{replace_special_characters}{A character vector. If not \code{NULL},
strings will be transliterated via \code{stringi::stri_trans_general}. It is also possible to supply
a character vector (for example "germany"), which transliterates according to some implemented dictionary (umlauts are transliterated to oe, ae, ...).
It is possible to combine ids from \code{stringi::stri_trans_list()} and dictionaries from this packages.
Currently implemented dictionaries: "german".
You should use this feature with care in case of \code{case = "parsed"} and \code{case = "none"}, 
since for upper case letters, which have transliterations of lenth 2, the second letter will
be transliterated to lowercase, for example Oe, Ae, Ss, ...}

\item{postprocess}{String that will be used as separator. The defaults are \code{"_"} 
and \code{""}, regarding the specified \code{case}.}

\item{prefix}{prefix (string).}

\item{postfix}{postfix (string).}

\item{unique_sep}{A string. If it is supplied, then duplicated names will get a suffix integer
in the order of their appearance. The suffix is separated by the supplied string to this argument.}

\item{empty_fill}{A string. If it is supplied, then each entry that matches "" will be replaced
by the supplied string to this argument.}

\item{parsingoption}{An integer (1 (default), 2 or 3) that will determine the parsingoption.
1: RRRStudio -> RRR_Studio
2: RRRStudio -> RRRS_tudio
3: parses the first UPPER letter group like parsingoption 2 and the rest like option 1
4: parses the first UPPERlowercase letter group like parsingoption 1 and the rest like option 2
if another integer is supplied, no parsing regarding the pattern of upper- and lowercase will appear.}
}
\value{
A character vector according the specified parameters above.
}
\description{
Function to convert strings to any case
}
\note{
\code{to_any_case()} is vectorised over \code{postprocess}, \code{prefix} and \code{postfix}.
\code{postprocess} might follow in the future.
}
\examples{
### Default usage
strings <- c("this Is a Strange_string", "AND THIS ANOTHER_One")
to_any_case(strings, case = "snake")
to_any_case(strings, case = "small_camel")
to_any_case(strings, case = "big_camel")
to_any_case(strings, case = "screaming_snake")
to_any_case(strings, case = "parsed")

### Pre -and postprocessing
strings2 <- c("this - Is_-: a Strange_string", "AND THIS ANOTHER_One")
to_snake_case(strings2)
to_any_case(strings2, case = "snake", preprocess = "-|\\\\:")

to_any_case(strings2, case = "snake", preprocess = "-|\\\\:", postprocess = " ")
to_any_case(strings2, case = "big_camel", preprocess = "-|\\\\:", postprocess = "//")

### Pre -and postfix
to_any_case(strings2, case = "big_camel", preprocess = "-|\\\\:", postprocess = "//",
            prefix = "USER://", postfix = ".exe")

### Special characters like german umlauts for example can be replaced via 
# replace_special_characters = TRUE

### Protect anything that shouldn't have an underscore beside in the output
strings3 <- c("var12", "var1.2", "va.r.1.2")
to_any_case(strings3, case = "snake")
to_any_case(strings3, case = "snake", protect = "\\\\d")
to_any_case(strings3, case = "snake", protect = "\\\\d|\\\\.")

}
\seealso{
\href{https://github.com/Tazinho/snakecase}{snakecase on github} or 
\code{\link{caseconverter}} for some handy shortcuts.
}
\author{
Malte Grosser, \email{malte.grosser@gmail.com}
}
\keyword{utilities}

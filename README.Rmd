---
title: "snakecase"
output: rmarkdown::github_document
---

[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/Tazinho/snakecase?branch=master&svg=true)](https://ci.appveyor.com/project/Tazinho/snakecase) [![Travis-CI Build Status](https://travis-ci.org/Tazinho/snakecase.svg?branch=master)](https://travis-ci.org/Tazinho/snakecase) [![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/snakecase)](https://cran.r-project.org/package=snakecase) [![Coverage Status](https://img.shields.io/codecov/c/github/Tazinho/snakecase/master.svg)](https://codecov.io/github/Tazinho/snakecase?branch=master)

A small package with functions to convert column names of data.frames (or strings
in general) to different cases like snake_case, smallCamel- and BigCamelCase among others. Also high level features for more advanced case conversions are provided.

## Install

```{r, results='hide', message=FALSE}
# install.packages("devtools")
devtools::install_github("Tazinho/snakecase", ref = "devversion-01", force = TRUE)
```

## Usage

```{r, collapse=TRUE, message=FALSE}
library(snakecase)

strings <- c("smallCamelCase", "BigCamelCase", "SCREAMING_SNAKE_CASE",
             "RRRProjectRRProject", "große Männer_1.2_3-4/5", NA)

# conversion
to_snake_case(strings)

to_small_camel_case(strings)

to_big_camel_case(strings)

to_screaming_snake_case(strings)

to_any_case(strings,
            case = "big_camel", 
            preprocess = "\\.|-|/", 
            replace_special_characters = TRUE)

to_any_case(strings,
            case = "screaming_snake",
            preprocess = "\\.|-|/",
            postprocess = "/",
            prefix = "USER/",
            postfix = ".exe",
            replace_special_characters = TRUE)

# test if your names are a valid case (consistent with this package)
# for example smallCamelCase
strings == to_small_camel_case(strings)

# compare input and output
library(dplyr)

tibble(inp = strings, outp = to_small_camel_case(strings)) %>% 
  mutate(compare = inp == outp)
```

## Design Philosophy

# Practical influences

Conversion to a specific target case is not always obvious or unique. In general a clean conversion
can only be guaranted, when the input-string is meaningful.

Take for example a situation where you have IDs for some customers. Instead of calling the column "CustomerID" you abbreviate it to "CID". Without further knowledge about the meaning of CID it will be impossible to know that it should be converted to "c_id", when using `to_snake_case()`. Instead it will be converted to:

```{r, collapse=TRUE}
to_snake_case("CID")
```

We could have also converted to "c_i_d" and if we don't know the meaning of "CID", we can't decide which one is the better solution. However it is easy to exclude specific approaches by counterexamples. So in practice it might be nicer to convert "SCREAMING_SNAKE_CASE" to "screaming_snake_case" instead of "s_c_r_e_a_m_i_n_g_s_n_a_k_e_c_a_s_e", which means that also "cid" is preferable to "c_i_d".

Since the computer can't know, that we want "c_id" by himself. It is easiest, if we provide him with the right information (here in form of a valid PascalCase syntax):

```{r, collapse=TRUE}
to_snake_case("CId")
```

In this way it is guaranteed to get the correct conversion and the only chance of an error lies in an accidentally wrong provided input string or a bug in the converter function `to_snake_case()`.

## Consistent behaviour

In many scenarios the analyst doesn't have a big influence on naming conventions and sometimes there might occur situations where it is not possible to find out the exact meaning of a variable name, even if we ask the original author. In some cases data might also have been named by a machine and the results can be relatively technically. So in general it is a good idea to compare the input of the case converter functions with their output, to see if the intended meanings at least seem to be preserved.

To make this as painless as possible, it is best to provide a logic that is robust and can handle also relatively complex cases. Note for example the string "RStudio". How should one convert it to snake case? We have seen a similar example with "CId", but for now we focus on sth. different. In case of "RStudio", we could convert to: 

1. "r_s_tudio",
1. "rs_tudio" or
1. "r_studio".

If we are conservative about any assumptions on the meaning of "RStudio", we can't decide which is the correct conversion. It is also not valid to assume that "RStudio" was intentionally written in PascalCase. Of course we know that "r_studio" is the correct solution, but we can get there also via different considerations. Let us try to convert our three possible translations (back) to PascalCase and from there back to snake case. What should the ouput look like?

1. r_s_tudio -> RSTudio -> r_s_t_udio
1. rs_tudio  -> RsTudio -> rs_tudio
1. r_studio  -> RStudio -> r_studio

Both of the first two alternatives can't be consistently converted back to a valid Pascal case input ("RStudio") and with the first logic the further snake case conversion seems to be complete nonsense. Only the latter case is consistent, when converting back to PascalCase, which is the case of the input "RStudio". It is also consistent to itself, when converting from PascalCase back to snake_case.  

In this way, we can get a good starting point on how to convert specifc strings to valid snake_case. Once we have a clean snake_case conversion, we can easily convert further to smallCamelCase, BigCamelCase, SCREAMING_SNAKE_CASE or anything else.

## Three rules of consistency

To be consistent regarding the conversion between different cases, we can introduce some conversion equations which should always hold, when switching from one to another case.

Below you can see the current bahaviour. Those examples that behave as intended (X) and are also tested (`*Td*`) will be stable in the future.
Others might be considered to be changed.



In general it might be desirable to have at least sth. like "pairwise inversity" of the three `to_xxx` functions on the space of `to_xxx(string)`. So it might be a good criterion if the following equation holds for any input string:

1. `to_A(to_B(to_A(string))) = to_A(string)`, (note that this might be equivalent to `to_A(to_B(string))) = to_A(string)`)

where `to_A` and to `to_B` can be `to_snake_case`, `to_small_camel_case` and `to_big_camel_case`.

Note that equality in this equation is only one criterion and it still doesn't
imply a unique solution on how to translate an initial string argument to snake or camel case. (Note that also `to_xxx(string) = to_xxx(string)` seems desirable). However, for the 
following testcases, also these two equations are tested.

# Tests

```{r, echo = FALSE}
cases <- c(NA,
           "snake_case", "snakeCase",
           "SnakeCase", "_", "snake_Case", 
           "_", "SNake", "Snake",
           "s_nake", "sn_ake", "_",
           "SNaKE", "SNaKEr", "s_na_k_er", "_",
           "SNAKE SNAKE CASE", "_",
           "snakeSnakECase", "SNAKE snakE_case", "_",
           "bangBooMBang",
           "upPER", "CId", "_",
           "___", ".", "...",
           "Sepal.Width", "Var 1", "Var-2",
           "Var.3", "Var4",
           "SnakeCase",
           "Snake-Case",
           "Snake Case",
           "Snake  -  Case")

knitr::kable(tibble::tibble(nr = seq_along(cases),
                            examples = cases,
                            snake_case = snakecase::to_snake_case(cases),
                            #snake_case_dev = snakecase::to_snake_case_dev(cases),
                            smallCamelCase = snakecase::to_small_camel_case(cases),
                            BigCamelCase = snakecase::to_big_camel_case(cases),
                            `As intended?` = c("\\*Td\\*, X", "\\*Td\\*, X", "\\*Td\\*, X",
                                               "\\*Td\\*, X", "", "\\*Td\\*, X",
                                               "", "\\*Td\\*, ?", "\\*Td\\*, X",
                                               "\\*Td\\*, X", "\\*Td\\*, X",
                                               "", "\\*Td\\*, ?", "\\*Td\\*, ?",
                                               "\\*Td\\*, X",
                                               "", "X \\*Td\\*",
                                               "",
                                               ", \\*Td\\*",
                                               "_ ?", "",
                                               "_ X",
                                               "_ X", "_ ? (maybe c_id)", "_ ?",
                                               "_ ?", "_ ?", "_ ?",
                                               "_ X", "_ ? (maybe var1)", "_ ?", 
                                               "_ ? (maybe var3)", "_ X",
                                               "","","",""))
             )
```